# 前端知识对比手册（持续更新）
#### 我很喜欢以对比的方式记录一些容易混淆或者迷惑的前端特性和概念

（整理自FEZIRO，内容参考自MDN Web Docs）

<br>

## 伪类和伪元素对比
 名称 | 语法 | 数量 | 作用
-|-|-|-
伪类 | ： | 可单个可多个叠加 | 基于DOM产生不同修饰DOM元素的状态
伪元素 | ：： | 只能单个使用 | 创建不存在DOM中的新元素对象
<br/>

## let和const和var对比
 名称 | 变量提升 | 全局变量 | 重复声明 | 重新赋值 | 暂时死区|块作用域|只声明不初始化
 -|-|-|-|-|-|-|-|
var|√|√|√|√|x|x|√
let |x|x|x|√|√|√|√
const|x|x|x|x|√|√|x
<br>

## visiable：hidden 和 opacity：0 和 display：none对比
名称|作用|可否点击
-|-|-|
visiable：hidden|占位隐藏|否
opacity：0|占位隐藏|是
display：none|不占位隐藏|否
<br>

## 单行溢出隐藏、多行溢出隐藏
名称| css
-|-
单行溢出|`width:150px(固定宽度)`<br>`white-space:no-wrap`<br>`overflow:hidden`<br>`text-overflow:ellipsis`
多行溢出|`width:150px（固定宽度）`<br>`display:-webkit-box;`<br>`-webkit-box-orient:vertical`<br>`-webkit-line-camp:3`<br>`overflow:hidden`
<br>

## Set、Map和WeakSet、WeakMap的区别
1. WeakSet和WeakMap类没有entiries, keys, values等方法，无法被遍历。
2. WeakSet和WeakMap类只能用对象作为键（key），没有强引用的键，垃圾回收机制可以回收。
3. set, map键和值可以是任意类型。
<br>

## flex：1是什么
flex：1|等于
-|-
flex：1|flex-grow：1;<br>flex-shrink: 1;<br>flex-basis: 1;<br>
<br>

## flex布局子项单独靠右
```
  //父元素
  display: flex;
  align-items: center;

  （方法1）
  //子元素
  flex: 1;
  text-align: right;

  （方法2）
  //子元素
  margin-left: auto;
```
<br>

## 垃圾回收GC机制
机制|工作原理
-|-
标记清除|标记方式：特殊位的反转、维护一个列表<br>原理：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量已经被环境中变量被标记为引用的变量，在此之后再被标记的变量将被视为准备删除的变量。最后垃圾回收器清除标记的变量，回收它们所占用的内存空间，目前主流浏览器都是使用标记清除式的垃圾回收策略，只不过收集的间隔有所不同。
引用计数| 原理：每次引用加一，被释放时减一，当这个值的引用次数变成 0 时，就可以将其内存空间回收<br>缺点：循环引用(obj1 和 obj2 通过各自的属性相互引用，也就是说，这两个对象的引用次数都是 2)

<br>

## ES7/ES8新特性
版本|新特性
-|-
ES7| 求幂运算符（**）<br>新增Array.prototype.includes()方法<br>
ES8| async、await异步解决方案<br>Object.entries()<br>Object.values()<br>Object.getOwnPropertyDescriptors获取对象的属性描述符<br>字符串填充padStart()、padEnd()<br>



<br>

## OSI七层网络模型对比图
"如图片无法加载请在images文件夹下查看"
![OSI模型图](https://github.com/FEZIRO/feziro-front-end-learning-handbook/blob/master/images/20190105161812494.png)



<br>

## null、undefined、NaN区别

| 名称      | 含义                                                         | 特性                                          |
| --------- | ------------------------------------------------------------ | --------------------------------------------- |
| null      | 是一个字面量，指示变量未指向任何对象, 但变量存在且不报undefined错 | 在布尔运算中被认为是falsy<br>类型判断是object |
| undefined | 一个没有被赋值的变量的类型是undefined。如果方法或者是语句中**操作的变量没有被赋值，则会返回undefined** | 原始数据类型<br>类型判断是undefined           |
| NaN       | 不是一个数字                                                 | 不等于任何值，自己不等于自己，可用isNaN()检测 |

<br>

## 严格模式中的变化

1. 无法再意外创建**全局变量。**
2. 使引起静默失败**(注:不报错也没有任何效果)**的赋值操作抛出异常。
3. **试图删除不可删除的属性时会抛出异常**。
4. **要求一个对象内的所有属性名在对象内必须唯一。**正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码要去改变属性值而不是修改最后一个重名属性的时候，复制这个对象就产生一连串的bug。在严格模式下，重名属性被认为是语法错误。
5. **要求函数的参数名唯一。**在正常模式下, 最后一个重名参数名会掩盖之前的重名参数. 之前的参数仍然可以通过 `arguments[i] 来访问`, 还不是完全无法访问. 然而, 这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了), 所以在严格模式下重名参数被认为是语法错误。
6. **禁止八进制数字语法**。
7. **禁止设置primitive值的属性**，不采用严格模式,设置属性将会简单忽略(no-op),采用严格模式,将抛出TypeError错误。
8. **禁用 with语句**。
9. **严格模式下 eval 仅仅为被运行的代码创建变量**, 所以 eval 不会使得名称映射到外部变量或者其他局部变量。
10. **禁止删除声明变量。**
11. **严格模式中一部分字符变成了保留的关键字**。这些字符包括`implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`和`yield`。在严格模式下，你不能再用这些名字作为变量名或者形参名。
12. **禁止不在脚本或者函数层面上的函数声明**。在浏览器的普通代码中，在“所有地方”的函数声明都是合法的。
13. **不再支持 arguments.callee。**
14. **参数的值不会随 arguments 对象的值的改变而变化**
15. **名称 eval和 arguments不能通过程序语法被绑定(be bound)或赋值.**

<br>

## JavaScript基本数据类型（primitive）？

是一种既非对象也无方法的数据（primitive），基本类型值可以被替换，但不能被改变。

共有7种基本类型：**string，number，bigint，boolean，null，undefined，symbol**

<br>

## encodeURI和encodeURIComponent区别

| 名称                                   | 区别                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| encodeURI、decodeURI                   | 不会对 ASCII字母、数字、~!@#$&*()=:/,;?+'进行编码解码，编码整个URL，然后需要使用这个URL推荐使用 |
| encodeURIComponent、decodeURIComponent | 除 A-Z a-z 0-9 - _ . ! ~ * ' ( )之外编码解码一切字符，编码的范围更广，编码URL中的参数的时候推荐使用 |

<br>

## HTTP1.0、1.1、2.0区别

| 版本     | 特性                                                         |
| -------- | ------------------------------------------------------------ |
| HTTP 1.0 | 1、使用header里的**If-Modified-Since,Expires**来做为缓存判断的标准<br>2、**不支持断点续传功能**（部分内容传输）<br>3、请求消息中的URL并**没有传递主机名**（hostname）<br> |
| HTTP 1.1 | 1、**支持长连接和请求的流水线处理，连接可以复用**，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点<br>2、引入了**更多的缓存控制策略**例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略<br>3、**请求头引入了range头域**，它允许只请求资源的某个部分，即返回码是206（Partial Content）<br>4、**新增了24个错误状态响应码**<br>5、**请求消息和响应消息都应支持Host头域**，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）<br> |
| HTTP 2.0 | 1、**新的二进制格式**，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。<br>2、**多路复用**，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。<br>3、**header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。<br>4、**服务端推送**，同SPDY一样，HTTP2.0也具有server push功能。<br> |

<br>

## HTTP2.0多路复用、HTTP1.x长连接区别

| 名称            | 区别                                                         |
| --------------- | ------------------------------------------------------------ |
| HTTP1.x长连接   | 打开一次tcp连接，请求就复用此连接，但是得排队，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。<br>**减少TCP连接耗时** |
| HTTP2.0多路复用 | 打开一次tcp连接，请求就复用此连接，不同排队，多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行<br>**减少TCP连接耗时，优化请求阻塞情况**<br> |

![区别图](/Users/feziro/Desktop/前端学习对比手册/images/http长连接和多路复用区别.png)

<br>

## HTTP状态码区别

| 状态码类别 | 具体状态码                                                   |
| ---------- | ------------------------------------------------------------ |
| 100        | **100 Continue **表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略 <br>**101 Switching Protocol **表示服务器应客户端升级协议的请求（`Upgrade`请求头）正在进行协议切换 |
| 200        | **200 OK **请求已经成功，默认情况下状态码为200的响应可以被缓存<br/>**201 Created**  表示请求已经被成功处理，并且创建了新的资源<br>**202 Accepted** 表示服务器端已经收到请求消息，但是尚未进行处理<br/>**203 Non-Authoritative Information** 表示请求已经成功被响应，但是获得的负载与源头服务器的状态码为 200的响应相比，经过了拥有转换功能的 代理服务器的修改<br/>**204 No Content **成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。默认情况下 204 响应是可缓存的。一个 ETag标头包含在此类响应中<br/>**205 Reset Content** 用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面。<br/>**206 Partial Content** 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range首部指定的。 |
| 300        | **300 Multiple Choices** 表示重定向的响应状态码，表示该请求拥有多种可能的响应<br/>**301 Moved Permanently (永久重定向)** 说明请求的资源已经被移动到了由 Location 头部指定的url上，是固定的不会再改变。搜索引擎会根据该响应修正，<u>请求方法有时候会被客户端错误地修改为 GET 方法</u><br/>**302 Found （临时重定向）** 重定向状态码表明请求的资源被暂时的移动到了由Location 头部指定的 URL 上。浏览器会重定向到这个URL， 但是搜索引擎不会对该资源的链接进行更新，<u>请求方法有时候会被客户端错误地修改为 GET方法</u><br/>**303 See Other** 重定向状态码，通常作为 PUT或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET<br/>**304 Not Modified** 说明无需再次传输请求的内容，可以使用缓存的内容<br/>**307 Temporary Redirect（临时重定向）**是表示重定向的响应状态码，说明请求的资源暂时地被移动到  Location 之间的唯一区别在于，当发送重定向请求的时候，<u>可以确保请求方法和消息主体不会发生变化。</u><br/>**308 Permanent Redirect（永久重定向）**是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接，<u>可以确保请求方法和消息主体不会发生改变</u> |
| 400        | **400 Bad Request** 响应状态码表示由于语法无效，服务器无法理解该请求。 客户端不应该在未经修改的情况下重复此请求。<br/>**401 Unauthorized** 代表客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。<br/>**402 Payment Required** （实验功能）是一个被保留使用的非标准客户端错误状态响应码<br/>**403 Forbidden** 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。<br/>**404 Not Found** 代表客户端错误，指的是服务器端无法找到所请求的资源，不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 [`410`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/410) (Gone) 而不是 404<br/>**405 Method Not Allowed** 表明服务器禁止了使用当前 HTTP 方法的请求<br/>**406 Not Acceptable** 状态码表示客户端错误，指代服务器端无法提供与 Accept-Charset 以及 Accept-Language消息头指定的值相匹配的响应。<br/>**407 Proxy Authentication Required**代表客户端错误，指的是由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器proxy server要求的身份验证凭证，发送的请求尚未得到满足。<br/>**408 Request Timeout** 表示服务器想要将没有在使用的连接关闭。一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下。<br/>**409 Conflict** 表示请求与服务器端目标资源的当前状态相冲突。<br/>**410 gone（丢失）**说明请求的内容在服务器上不存在了，同时是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用404<br/>**411 Length Required** 属于客户端错误，表示由于缺少确定的Content-Length首部字段，服务器拒绝客户端的请求。<br/>**412 Precondition Failed**（先决条件失败）表示客户端错误，意味着对于目标资源的访问请求被拒绝。这通常发生于采用除 GET和 HEAD 之外的方法进行条件请求时，由首部字段 if-Unmodified-Since或 If-None-Match规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。<br/>**414 URI Too Long** 表示客户端所请求的 URI 超过了服务器允许的范围。<br/>**415 Unsupported Media Type**是一种HTTP协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。<br/>**416 Range Not Satisfiable** 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。<br/>**417 Expectation Failed** 状态码表示客户端错误，意味着服务器无法满足 Expect请求消息头中的期望条件。<br/>**425 Too Early** 代表服务器不愿意冒风险来处理该请求，原因是处理该请求可能会被“重放”，从而造成潜在的重放攻击<br/>**426 Upgrade Required** 是一种HTTP协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求<br/>**428 Precondition Required** 表示服务器端要求发送条件请求。<br/>**429 Too Many Requests**表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”。<br>**431 Request Header Fields Too Large**表示由于请求中的首部字段的值过大，服务器拒绝接受客户端的请求。客户端可以在缩减首部字段的体积后再次发送请求<br>**451 Unavailable For Legal Reasons （因法律原因不可用）**是一种HTTP协议的错误状态代码，表示服务器由于法律原因，无法提供客户端请求的资源，例如可能会导致法律诉讼的页面。<br> |
| 500        | **500 Internal Server Error**  意味着所请求的服务器遇到意外的情况并阻止其执行请求。<br/>**501 Not Implemented** 服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理，响应默认是可缓存的<br/>**502 Bad Gateway** 它表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的<br/>**503 Service Unavailable** 它表示服务器尚未处于可以接受请求的状态。<br/>**504 Gateway Timeout** 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应<br/>**505 HTTP Version Not Supported** 表示服务器不支持请求所使用的 HTTP 版本<br/>**506 Variant Also Negotiates** 响应状态码可以在TCN（透明内容协商，见RF2295）上下文给出。TCN协议允许客户端取回给定资源的最佳变量/变元，这里服务器支持多个变量/变元。<br/>**507 Insufficient Storage**响应状态码 可以在WebDAV协议（基于web的分布式创作和版本控制，参见[RFC 4918](https://tools.ietf.org/html/rfc4918)）中给出。<br/>**508 Loop Detected** 状态码可以在WebDAV协议（基于Web的分布式创作和版本控制）中给出，表示服务器中断一个操作<br/>**510 Not Extended** 响应状态码在HTTP扩展框架协议（参见[RFC 2774](https://tools.ietf.org/html/rfc2774)）中发送。<br/>**511 Network Authentication Required** 表示客户端需要通过验证才能使用该网络。该状态码不是由源头服务器生成的，而是由控制网络访问的拦截代理服务器生成的。 |

<br>

## HTTP请求头区别

幂等性：连续调用一次或者多次的效果相同（无副作用）

安全性：这里指的安全指的是不会修改服务器数据、对服务器只读操作的方法（不是加密传输）。

| 请求头  | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| CONNECT | **可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel），可以用来访问采用了SSL（HTTPS） 协议的站点<br>**请求主体 NO<br>响应主体 YES<br>安全性 NO<br/>幂等性 NO<br/>可缓存 NO<br/>HTML 表单支持  NO<br> |
| DELETE  | **用于删除指定的资源，可能返回的状态码200，202，204<br>**请求主体 May 可以有<br/>响应主体 May 可以有<br/>安全性 NO<br/>幂等性 YSE<br/>可缓存 NO<br/>HTML 表单支持  NO<br/> |
| GET     | **用于求指定的资源<br>**请求主体 NO<br/>响应主体 YES<br/>安全性 YES<br/>幂等性 YES<br/>可缓存 YES<br/>HTML 表单支持 YES<br/> |
| POST    | **发送数据给服务器. 请求主体的类型由 Content-Type首部指定**<br>请求主体 YES<br/>响应主体 YES<br/>安全性 NO<br/>幂等性 NO<br/>可缓存 只有是新鲜的信息才可被缓存<br/>HTML 表单支持  YES<br/> |
| OPTIONS | **用于获取目的资源所支持的通信选项**<br>请求主体 NO<br/>响应主体 NO<br/>安全性 YES<br/>幂等性 YES<br/>可缓存 NO<br/>HTML 表单支持  NO<br/> |
| PATCH   | **用于对资源进行部分修改**<br>请求主体 YES<br/>响应主体 NO<br/>安全性 NO<br/>幂等性 NO<br/>可缓存 NO<br/>HTML 表单支持  NO<br/> |
| PUT     | **使用请求中的负载创建或者替换目标资源**<br>请求主体 YES<br/>响应主体 NO<br/>安全性 NO<br/>幂等性 YES<br/>可缓存 NO<br/>HTML 表单支持  NO<br/> |
| TRACE   | **实现沿通向目标资源的路径的消息环回（loop-back）测试 ，提供了一种实用的 debug 机制**<br>请求主体 NO<br/>响应主体 NO<br/>安全性 NO<br/>幂等性 YES<br/>可缓存 NO<br/>HTML 表单支持  NO<br/> |
| HEAD    | **请求资源的头部信息, 并且这些头部与 HTTP GET方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源**<br>请求主体 NO<br/>响应主体 NO<br/>安全性 YES<br/>幂等性 YES<br/>可缓存 YES<br/>HTML 表单支持  NO<br/> |

<br>

## POST请求主体格式区别

| 格式                              | 区别                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| application/x-www-form-urlencoded | **浏览器默认的编码格式，将键值对的参数用&连接起来，如果有空格，将空格转换为`+`加号；有特殊符号，将特殊符号转换为`ASCII HEX`值，只适合传输键值对参数，不支持二进制数据** |
| multipart/form-data               | **不会对参数编码，使用的`boundary`(分割线)，相当于`&`，`boundary`的值是`----Web\**AJv3，适合用于上传文件（二进制数据）和键值对参数`** |

