## Vue生命周期对比

| 名称          | 特点                                                         | 使用场景                                              |
| ------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| beforeCreate  | 钩子执行前实例化Vue对象，初始化时间&生命周期<br>不能访问到data，computed，watch，method | 常用于初始化非响应式变量                              |
| created       | 钩子执行前先输入数据和数据响应化处理<br/>能访问到data，computed，watch，method<br>没有挂在dom，不能访问到$el，$ref | 后端数据请求                                          |
| beforeMounted | 钩子执行前先判断挂载方式，检查模板，再编译成render函数<br/>数据未挂载，页面中的{{}}还没有被替换掉 | ——                                                    |
| mounted       | 钩子执行前先创建vm.$el并替换真实元素<br/>实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | 后端数据请求                                          |
| beforeUpdate  | 钩子执行前先检测data是否被改变<br/>响应式数据更新时调用，发生在虚拟DOM打补丁之前，数据更新了，但vue组件对象对应的dom中的内部（innerHTML）没有变 | 更新之前访问现有的DOM，比如手动移除已添加的事件监听器 |
| updated       | 钩子执行前先检查虚拟DOM是否重新渲染并应用更新<br/>虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | ——                                                    |
| beforeDestory | 钩子执行前先检查元素是否被销毁<br/>实例仍然完全可用，this仍能获取到实例 | ——                                                    |
| destory       | 钩子执行前先解除绑定，销毁子组件和事件监听器                 | ——                                                    |



## v-if和v-show区别对比

| 名称   | 特点                                                         |
| ------ | ------------------------------------------------------------ |
| v-if   | 值为false，页面不存在此html标签                              |
| v-show | 不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏 |



## Vue-Router导航守卫对比

| 名称             | 方法                                                         | 特点                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| 全局守卫         | **router.beforeEach** 进入某路由之前<br/>**router.beforeResolve** 在beforeRouteEnter调用之后调用<br/>**router.afterEach** 全局后置钩子，进入某路由之后 | 适用于全局导航<br>在路由实例router实现            |
| 路由独享守卫     | **beforeEnter **进入某路由之前                               | 为某些路由单独配置守卫<br>在导航配置表route内实现 |
| 路由组件内的守卫 | **beforeRouteEnter** 进入路由前, 在路由独享守卫后调用不能获取组件实例 this，组件实例还没被创建<br/>**beforeRouteUpdate** 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this<br/>**beforeRouteLeave** 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this | 为某些组件单独配置导航守卫<br>在组件内实现        |

#### 完整的导航解析流程

1. 导航被触发。
2. 在失活的组件里调用离开守卫。**（路由组件内的守卫）**
3. 调用全局的 beforeEach 守卫。**（全局守卫）**
4. 在重用的组件里调用 beforeRouteUpdate 守卫 。**（路由组件内的守卫）**
5. 在路由配置里调用 beforeEnter。**（路由独享守卫）**
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter。**（路由组件内的守卫）**
8. 调用全局的 beforeResolve 守卫 **（全局守卫）**
9. 导航被确认。
10. 调用全局的 afterEach 钩子。**（全局守卫）**
11. 触发 DOM 更新。
12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。**（路由组件内的守卫）**



## Vue-Router模式对比

| 名称    | 特点                                                         |
| ------- | ------------------------------------------------------------ |
| Hash    | **通过hash（#）锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据**，hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响<br>通过onhashchange 事件监测hash值变化 |
| history | **通过h5新接口pushState() ，replaceState()，popState()事件实现，它们提供了对历史记录修改的功能**。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求<br>需要后台配置找不到资源时的跳转界面，否则返回404错误 |



## Vue3.0的响应式对比2.x的响应式区别对比

| 名称                  | 特点                                                         | 版本   |
| --------------------- | ------------------------------------------------------------ | ------ |
| Object.defineProperty | 不能监听数组的变化<br>必须遍历对象的每个属性<br>必须深层遍历嵌套的对象 | vue2.x |
| proxy                 | 可以劫持整个对象<br>支持代理数组<br>支持代理动态增加的属性<br>有 13 种拦截方法 | Vue3.0 |



## Vue组件传值方式对比

| 名称                          | 使用场景                     |
| ----------------------------- | ---------------------------- |
| props属性传值                 | 父传子                       |
| $emit/$on                     | 子传父                       |
| EventBud                      | 无限制                       |
| Vuex                          | 无限制                       |
| $children / $parent           | 只能用于父子之间             |
| provide/ reject               | 父传子，跨级                 |
| ref / refs                    | 无限制，可访问任何实例的元素 |
| localStorage / sessionStorage | 无限制                       |
| $attrs / $listeners           | 父子，跨级                   |

**常见使用场景可以分为三类:**
1、父子组件通信: props，$parent / $children， provide / inject， refs，  $attrs / $listeners
2、兄弟组件通信: eventBus ; vuex
3、跨级通信:  eventBus；Vuex；provide / inject 、$attrs / $listeners



## watch和computed区别对比

| 名称          | 特点                                                         |
| ------------- | ------------------------------------------------------------ |
| props属性传值 | 1、可接受两个参数（新值和旧值）<br/>2、监听时可触发一个回调，并做一些事情<br>3、监听的属性必须是存在的<br>4、允许异步 |
| computed      | 1、缓存机制<br/>2、不接受参数<br>3、可以依赖其他 computed，甚至是其他组件的 data<br>4、不能与data中的属性重复 |



## 3种路由传参方式区别对比

| 名称        | 特点                                                         | 缺点     |
| ----------- | ------------------------------------------------------------ | -------- |
| 动态URL参数 | 向URL路径设置参数，通过this.$route.params获取参数            | 参数暴露 |
| params对象  | 跳转时设置跳转params参数对象                                 | 刷新丢失 |
| query对象   | 跳转时设置跳转query参数对象，query传递的参数会显示在url后面?id=？<br>通过this.$route.query获取参数 | 参数暴露 |

**什么时候用this.$route.params.xxx ? 什么时候用this.$route.query.xxx ?**

参数是对象的时候用this.$router.params.xxx 

参数是字符串拼接的时候用this.$router.query.xxx